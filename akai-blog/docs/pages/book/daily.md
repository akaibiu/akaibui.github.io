# :woman_facepalming: 每日一问

>  以下所有学习资源以及面试题由小许师兄整理并收录，此栏目为学习内容。供参考学习。此后会不定期更新，谢谢您的关注与支持!


>文章来源:<br> <font color="#dd00dd"> &ensp;&ensp;&ensp;&ensp;一个站在技术顶流浪尖的烧男人 </font><br /><font color="#dd00dd">&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;小许师兄 </font><br />


>> `想的多了全是问题 做的多了全是答案` ————Mr.Xu

&ensp;&ensp;&ensp;[小许的花园](https://seniorbrother.com/)<br>
&ensp;&ensp;&ensp;[CSDN Xu](https://blog.csdn.net/weixin_55176089?type=blog)


## :sparkling_heart:Html

* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃


## :kissing_closed_eyes:css 

* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃

## :kissing_heart:JavaScript

#### 2023-03-07

* Q: <font color="#dd00dd">JS声明变量有哪些方式？</font>
* 
>在 JavaScript 中创建变量被称为“声明”变量。JavaScript中变量声明又分为显示声明和隐式声明。其中显示声明中，被“声明”变量之前的关键词有var、let、const、function、class、import ；另外，在隐式声明中，隐式变量是全局变量，如果在函数中，显示声明变量为局部变量，隐式声明为全局变量。

1. 用var定义变量。没有块的概念，可以跨块访问，不能跨函数访问；存在变量提升。
   1. var声明的变量可以不初始化赋值，输出是undefined，不会报错；
   2. var声明的变量可以修改，存在变量提升(大多数语言都有块级作用域，但JS使用var声明变量时，以function划分作用域，大括号“{}”去无法限值var的作用域)；
   3. var声明的变量作用域是全局的或者是函数级的；
   4. var声明的变量在window上；
   5. var定义的变量可以修改，如果不初始化会输出undefined，不会报错；
   6. var 声明的变量在window上，用let或者const去声明变量，这个变量不会被放到window上；
   7. 很多语言中都有块级作用域，但JS没有，它使用var声明变量，以function来划分作用域，大括号“{}” 却限定不了var的作用域，因此用var声明的变量具有变量提升的效果；
   8. var 声明的变量作用域是全局的或者是函数级的；
   9. var可以重复声明：var语句多次声明一个变量不仅是合法的,而且也不会造成任何错误；如果重复使用的一个声明有一个初始值,那么它担当的不过是一个赋值语句的角色；如果重复使用的一个声明没有一个初始值,那么它不会对原来存在的变量有任何的影响;


2. let声明的变量可以重新赋值但是不能重新声明定义
   1. 需要”javascript 严格模式”：'use strict'；
   2. let 不能重复声明
   3. 不会预处理,
   4. 不存在变量提升
   5. let声明的变量作用域是在块级域中，函数内部使用let定义后，对函数外部无影响(块级作用域)
   6. 可以在声明变量时为变量赋值，默认值为undefined,也可以稍后在脚本中给变量赋值，在生命前无法使用(暂时死区)
3. const定义的变量不可以被重新声明或赋值
   1. const定义的变量不可以修改，而且必须初始化
   2. 该变量是个全局变量，或者是模块内的全局变量；可以在全局作用域或者函数内声明常量，但是必须初始化常量
   3. 如果一个变量只有在声明时才被赋值一次，永远不会在其它的代码行里被重新赋值，那么应该使用const，但是该变量的初始值有可能在未来会被调整（常变量）
   4. 创建一个只读常量，在不同浏览器上表现为不可修改；建议声明后不修改；拥有块级作用域
   5. const 代表一个值的常量索引 ，也就是说，变量名字在内存中的指针不能够改变，但是指向这个变量的值可能 改变
   6. const定义的变量不可修改，一般在require一个模块的时候用或者定义一些全局常量
   7. 常量不能和它所在作用域内其它变量或者函数拥有相同名称

4. function声明一个函数变量
   1. 函数声明后不会立即执行，需要调用的时候才执行；
   2. 对支持ES5和ES6浏览器环境在块作用域内有一定区别，所以应避免在块级作用域内声明函数。
   3. 声明了一个名为 sum的新变量，并为其分配了一个函数定义
   4. {}之间的内容被分配给了 sum
5. class是es6的语法糖声明一个类，
   ```js
   class Point {
   constructor (x, y) {
     this.x = x;
     this.y = y;
   }
    toString () {
        return this.x + '：' + this.y;
    }
    }
    //使用Object.assign() 为对象添加方法属性
    Object.assign(Point.prototype, {
    getX () {
        return this.x;
    },
    getY () {
        return this.y;
    }
    })
    let p1 = new Point(1,2);
    console.log(p1.toString()); //1,2
    console.log(p1.getX()); //1
    console.log(p1.getY()); //2
    console.log(Object.keys(Point.prototype)); // ["getX", "getY"]  
   ```
   ```js
    class Point2 {
        constructor(xingBie, chineseName) {
            this.xingBie = xingBie;
            this.chineseName = chineseName;
        }
        getXingBie(){
            return `您的性别为${this.xingBie }`;
        }
        getChineseName(){
            return `您的中文名为${this.chineseName}`;
        }
    }
    
    var yogel = new Point2("男","油垢")
    console.log(yogel.getXingBie(),yogel.getChineseName())
   ```
    1. 方法之间不需要逗号分隔
    2. toString () {} 等价于 toString: function () {}
    3. 你仍然可以使用Point.prototype
    4. 你可以用Object.assign()一次性扩展很多方法
    5. 类内部定义方法多是不可以枚举的
    6. constructor(){}是一个默认方法，如果没有添加，会自动添加一个空的。
    7. constructor默认返回实例对象（this），完全可以指定返回其他的对象。
    8. 必须用new调用,不存在变量提升，当用一个变量去接受class时，可以省略classname
    9. es6不提供私有方法
    10. 使用extends继承

6. import ES6引入了自己的模块系统。通过export导出，import导入。与CommonJS不同的是，它是获取模块的引用，到用的时候才会真正的去取值。
7. 隐式声明变量
   1. 
    ```js
        coste = 15; // 赋值语句其实隐式的声明了变量coste，类型为数字，占用8个字节（64位浮点格式）
        console.log(coste) //15  所有隐式声明的变量默认都是全局变量，无论函数内外 
   ```
   2. 隐式声明的变量默认都是全局变量，无论函数内外
   3. 显式声明的变量不能用 delete 删除 因为它的 configurable: false，而隐式声明的变量 configurable: true
   4. 隐式声明变量虽然一定程度带来了方便，但是程序的可读性降低，无形之中会制造bug，应谨慎使用


8. JS变量声明提升和函数声明提升
   
>变量提升：在当前作用于中，js代码自上而下执行之前，浏览器会把所有带var/function关键字进行提前声明或定义。带var的关键字只是提前声明一下，带function的关键字在变量提升阶段把定义和声明都完成了。

   1. 函数提升优先级比变量提升要高，且不会被变量声明覆盖，但是会被变量赋值覆盖。
   2. 在js中变量和函数的声明会提升到最顶部执行
   3. 函数的提升高于变量的提升
   4. 函数内部如果用 var 声明了相同名称的外部变量，函数将不再向上寻找。
   5. 匿名函数不会提升。
9. 通过 function 声明的函数，在声明语句之前就可以直接调用值：函数定义（对象）

 





















## :stuck_out_tongue:es6

#### 2023-03-06

* Q: ES6中普通函数和构造函数的区别?

* A: 回答如下
* 
    1. `箭头函数，顾名思义，区别箭头写法`
   
    2. `箭头函数的没有this指向，普通函数中，指向调用它的对象！构造函数中指向对象实例！this指向无法修改`

    3. `没有原型，没有super() 没有原型  所以不能继承`

    4. `箭头函数 没有 arguments，接受参数解决方法 （...canshu）`

    5. `还不能作为构造函数`

    6. `类的内部所有定义的方法，都是不可枚举的（但是在es5中prototype的方法是可以进行枚举的）`

    7. `类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行`

    8. `Class不存在变量提升（hoist），这一点与ES5完全不同`

    9. `ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。`


## :yum:Vue

#### 2023-03-03

* Q: <font color="#dd00dd">vue中的v-for的key有什么作用?</font>
  
* A: 回答如下
   1. `Vue列表加key的目的是为diff算法添加标识，因为diff算法判断新旧VDOM是否相同的依据是节点的tag和key。如果tag和key相同则会进一步进行比较，使得尽可能多的节点进行复用。`
   
   2. `此外，key绑定的值一般是一个唯一的值，比如id。如果绑定数组的索引index，则起不到优化diff算法的作用，因为一旦数组内元素进行增删，后续节点的绑定的key也会发生变化，导致diff进行多余的更新操作`
   
   3. ` key的作用主要是为了高效的更新虛拟DOM，其原理是vue在patch（补丁）过程中通过key可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个patch过程更加高效，减少DOM操作量，提高性能。`

   4. `若不设置key还可能在列表更新时引发一些隐蔽的bug。如某行数据不该更新的却更新了。`
   
   5. `vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。`


## :yum:React

* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃

## :yum:Uniapp

* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃

## :yum:App

* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃
* 客官先别急，作者正在飞速收录中~😃

## :yum:Ui-Site




